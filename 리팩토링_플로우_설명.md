# 🔄 리팩토링된 주문/결제 플로우 설명

## 전체 아키텍처 개선사항

### 1. **OrderFacade - 주문 처리 진입점**
```java
public OrderResponse order(OrderCommand command) {
    // 1. 멱등성 체크 - 기존 주문이 있으면 반환
    return findExistingOrderResponse(command)
        .orElseGet(() -> createAndTriggerPayment(command));
}

private OrderResponse createAndTriggerPayment(OrderCommand command) {
    // 2. 주문 생성 트랜잭션 (재고차감/쿠폰적용/주문생성/요청접수)
    Order order = orderProcessor.process(command);
    
    // 3. 결제 트리거 (트랜잭션 밖에서)
    paymentService.pay(PaymentCommand.from(command, order));
    
    // 4. 요청 수락 기록
    orderRequestHistoryService.markAccepted(command.idempotencyKey());
    return new OrderResponse(order.getId(), order.getAmount().value(), order.getStatus());
}
```

### 2. **OrderProcessor - 트랜잭션 내 주문 생성**
```java
@Transactional
public Order process(OrderCommand command) {
    // 재고 차감 (동시성 제어)
    productService.checkAndDeduct(command.items());
    
    // 쿠폰 적용
    BigDecimal finalAmount = couponService.apply(command.userId(), command.couponId(), originalAmount);
    
    // 주문 생성
    Order order = orderService.createOrder(command.userId(), command.items(), OrderAmount.of(finalAmount));
    
    // 요청 히스토리: RECEIVED
    orderRequestHistoryService.saveReceived(command.idempotencyKey(), command.userId().value(), order.getId());
    return order;
}
```

### 3. **카드 결제 2-Phase 처리**
```java
@Override
public void pay(PaymentCommand cmd) {
    Long paymentId = createInitiated(cmd);     // Tx#1: 결제 생성
    PgPaymentResponse resp = requestPg(cmd);   // noTx: PG 호출
    updateAfterPg(paymentId, resp);            // Tx#2: 결과 업데이트
}
```

### 4. **포인트 결제 단일 트랜잭션**
```java
@Override
@Transactional
public void pay(PaymentCommand cmd) {
    // 중복 결제 가드
    if (paymentRepository.existsCompleted(cmd.orderId(), PaymentMethod.POINT)) return;
    
    // 포인트 차감
    pointService.deduct(cmd.userId(), amount);
    
    // 결제 완료 처리
    Payment completed = payment.withTransactionKey(txKey).completePayment("포인트 결제 완료");
    Payment saved = paymentRepository.save(completed);
    
    // 이벤트 발행
    eventPublisher.publishEvent(PaymentCompletedEvent.of(...));
}
```

### 5. **AFTER_COMMIT 이벤트 처리**
```java
@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
public void onPaymentCompleted(PaymentCompletedEvent event) {
    orderTransactionService.handlePaymentCompleted(event);
}

@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
public void onPaymentFailed(PaymentFailedEvent event) {
    orderTransactionService.handlePaymentFailed(event);
}
```

### 6. **보상 로직 (결제 실패 시)**
```java
@Transactional
public void handlePaymentFailed(PaymentFailedEvent event) {
    Order order = orderService.getOrder(event.orderId());
    orderService.markPaymentFailed(order, event.reason());
    compensationService.reverseFor(order.getId()); // 재고/쿠폰 복원
}

@Transactional
public void reverseFor(Long orderId) {
    productService.restoreByOrderId(orderId);  // 재고 복원
    couponService.releaseByOrderId(orderId);   // 쿠폰 해제
}
```

## 주요 개선사항

### ✅ 1. **트랜잭션 분리**
- 주문 생성과 결제 처리를 분리
- 카드 결제의 PG 호출을 트랜잭션 밖으로 이동
- 각 트랜잭션의 크기를 최소화

### ✅ 2. **이벤트 기반 비동기 처리**
- `@TransactionalEventListener(AFTER_COMMIT)` 사용
- 결제 완료/실패 후 주문 상태 변경
- 트랜잭션 커밋 후 안전한 이벤트 처리

### ✅ 3. **보상 로직 도입**
- 결제 실패 시 자동으로 재고/쿠폰 복원
- 데이터 정합성 보장

### ✅ 4. **명확한 네이밍**
- `savePending` → `saveReceived`
- `markSuccess` → `markAccepted`
- 비즈니스 의미가 더 명확함

### ✅ 5. **멱등성 보장**
- idempotencyKey를 통한 중복 요청 방지
- 각 결제 방식별 중복 처리 로직

## 테스트 시나리오

### 📋 **시나리오 1: 포인트 결제 성공**
1. 주문 생성 → 재고차감 → 쿠폰적용 → RECEIVED 기록
2. 포인트 차감 → 결제 완료 → PaymentCompletedEvent 발행
3. AFTER_COMMIT → 주문 상태 PAID로 변경

### 📋 **시나리오 2: 카드 결제 성공**
1. 주문 생성 → 재고차감 → 쿠폰적용 → RECEIVED 기록
2. 결제 INITIATED 생성 → PG 호출 → PROCESSING 상태 변경
3. PG 콜백 → PaymentCompletedEvent 발행
4. AFTER_COMMIT → 주문 상태 PAID로 변경

### 📋 **시나리오 3: 결제 실패 + 보상**
1. 주문 생성 → 재고차감 → 쿠폰적용
2. 결제 실패 → PaymentFailedEvent 발행
3. AFTER_COMMIT → 주문 실패 + 재고/쿠폰 복원

### 📋 **시나리오 4: 멱등성 테스트**
1. 같은 idempotencyKey로 재요청
2. 기존 주문 정보 반환 (중복 처리 없음)
